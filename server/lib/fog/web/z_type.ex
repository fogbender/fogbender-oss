defmodule Fog.Z do
  @moduledoc """
  Convert a Z.Struct into a JSON object and typescript. Use
  """

  def generate_file() do
    file = "../client/src/shared/z_types.ts" |> Path.expand()

    content =
      :code.all_loaded()
      |> Enum.map(fn {module, _} -> module end)
      |> Enum.filter(fn module -> module |> to_string |> String.starts_with?("Elixir.Fog.Z.") end)
      |> Enum.sort()
      |> Enum.map(fn module -> module.to_typescript() end)

    file_content = """
    // This file is generated by Fog.Z.generate_file()

    #{content |> Enum.join("\n")}
    """

    File.write!(file, file_content)

    "Generated #{content |> Enum.count()} typescript types in #{file}"
  end

  def name_to_typescript(name) do
    name
    |> to_string
    |> String.split(".")
    |> Enum.at(-1)
  end

  def field_to_typescript(name, {Z.String, [required: true]}) do
    "#{name}: string;"
  end

  def field_to_typescript(name, {Z.String, [required: true, enum: [value]]}) do
    "#{name}: \"#{value}\";"
  end

  def field_to_typescript(name, {module, [required: true, cast: true]}) do
    "#{name}: #{name_to_typescript(module)};"
  end

  def field_to_typescript(field, value) do
    raise "Fog.Z.field_to_typescript(#{inspect(field)}, #{inspect(value)}) is not implemented"
  end

  defmacro __using__(_) do
    quote do
      use Z.Struct

      alias Fog.Z, as: Z

      @derive Jason.Encoder

      def to_json!(struct) do
        case validate(struct) do
          {:ok, value} -> value |> Jason.encode!()
          {:error, error} -> raise "Failed to validate #{inspect(error)}"
        end
      end

      def from_map!(map) do
        # let's not worry about speed for now ðŸ˜…
        map |> Jason.encode!() |> from_json!()
      end

      def from_json(json) do
        case Jason.decode(json,
               keys: &Fog.Utils.maybe_atom/1
             ) do
          {:ok, value} -> validate(value, [:cast])
          {:error, error} -> {:error, error}
        end
      end

      def from_json!(enum \\ []) do
        case from_json(enum) do
          {:ok, value} -> value
          {:error, error} -> raise "Failed to validate #{inspect(error)}"
        end
      end

      def to_typescript() do
        name = __MODULE__ |> to_string |> String.split(".") |> Enum.at(-1)
        # @z_fields
        fields = __z__(:fields) |> Enum.map(fn {k, v} -> Fog.Z.field_to_typescript(k, v) end)
        out = ["export type #{name} = {\n  ", fields |> Enum.join("\n  "), "\n};\n"]
        IO.puts(out)
        out
      end
    end
  end
end

defmodule Fog.Z.APICodeChallengeVerifier do
  use Fog.Z

  schema do
    field(:codeChallenge, :string, [:required])
    field(:verifierEncoded, :string, [:required])
  end
end

defmodule Fog.Z.APIPagerdutyOauthCode do
  use Fog.Z

  schema do
    field(:code, :string, [:required])
    field(:verifierEncoded, :string, [:required])
  end
end

defmodule Fog.Z.APIFogbenderVisitor do
  use Fog.Z

  schema do
    field(:widgetId, :string, [:required])
    field(:widgetPaseto, :string, [:required])
  end
end
